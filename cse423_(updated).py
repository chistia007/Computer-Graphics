# -*- coding: utf-8 -*-
"""CSE423 (Updated).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16jRmRK6CI3wHlOskHRgYYVacoeuaXS5R
"""

!pip install tensorflow==1.15.0

!pip install -q lucid>=0.2.3
!pip install -q moviepy

!pip install imageio==2.4.1

import numpy as np
import json
import moviepy.editor as mvp
from google.colab import files
import tensorflow.compat.v1.gfile as gfile
import lucid.misc.io.showing as show

from lucid.misc.gl.glcontext import create_opengl_context

# Now it's safe to import OpenGL and EGL functions
import OpenGL.GL as gl
from OpenGL.GLU import *
# create_opengl_context() creates GL context that is attached to an
# offscreen surface of specified size. Note that rendering to buffers
# of different size and format is still possible with OpenGL Framebuffers.
#
# Users are expected to directly use EGL calls in case more advanced
# context management is required.
WIDTH, HEIGHT = 800,600
create_opengl_context((WIDTH, HEIGHT))
  
# OpenGL context is available here.

print(gl.glGetString(gl.GL_VERSION))
print(gl.glGetString(gl.GL_VENDOR)) 
#print(gl.glGetString(gl.GL_EXTENSIONS))

def addPixel(a,b):
  gl.glVertex2f(a/(WIDTH/2),b/(HEIGHT/2))

#--------------Lab1----------------
# Let's render something!
gl.glClear(gl.GL_COLOR_BUFFER_BIT)

gl.glColor3f(.5,.3,.7)
gl.glPointSize(5)

gl.glBegin(gl.GL_LINES)
gl.glVertex2f(0,-1)
gl.glVertex2f(0,1)
gl.glVertex2f(1,0)
gl.glVertex2f(-1,0)
gl.glEnd()

# gl.glColor3f(0,.5,0)
# gl.glBegin(gl.GL_POINTS)
# gl.glVertex2f(.75,.80 )
# gl.glVertex2f(.1, 0)
# gl.glEnd()


# gl.glColor3f(.5,.5,.7)
# gl.glBegin(gl.GL_LINES)
# gl.glVertex2f(-0.25,0)
# gl.glVertex2f(0.25,0)
# gl.glVertex2f(0.25,0)
# gl.glVertex2f(0,0.3)
# gl.glVertex2f(-0.25,0)
# gl.glVertex2f(0,0.3)
# gl.glEnd()

# gl.glColor3f(.5,.5,.7)
# gl.glBegin(gl.GL_LINE_STRIP)
# gl.glVertex2f(0,0.3)
# gl.glVertex2f(0.25,0)
# gl.glVertex2f(-0.25,0)
# gl.glVertex2f(0,0.3)
# gl.glEnd()

#gl.glColor3f(.5,.5,.7)

# gl.glBegin(gl.GL_TRIANGLES)
# gl.glColor3f(1,0,0)
# gl.glVertex2f(0,0.3)
# gl.glColor3f(0,0,1)
# gl.glVertex2f(0.25,0)
# gl.glColor3f(0,1,0)
# gl.glVertex2f(-0.25,0)
# gl.glEnd()



# gl.glColor3f(.5,.5,.7)
# gl.glBegin(gl.GL_QUADS)
# addPixel(-20,-20)
# addPixel(20,-20)
# addPixel(20,20)
# addPixel(-20,20)
# gl.glEnd()


# gl.glColor3f(165/255,61/255,1/255)
# gl.glBegin(gl.GL_POLYGON)
# addPixel(-20,-20)
# addPixel(20,-20)
# addPixel(20,20)
# addPixel(0,30)
# addPixel(-20,20)
# gl.glEnd()

#random 50 points---
# gl.glColor3f(0,.5,0)
# gl.glBegin(gl.GL_POINTS)
# import random
# for i in range(50):
#     a1= random.uniform(-1.0,1.0)
#     a2 = random.uniform(-1.0,1.0)
#     gl.glVertex2f(a1,a2)
# gl.glEnd()


#House-----
gl.glColor3f(.5,.5,.7)
gl.glBegin(gl.GL_LINES)
addPixel(-300,-280)  #LOWER SQUARE
addPixel(300,-280)
addPixel(-300,280)
addPixel(300,280)
addPixel(-300,280)
addPixel(-300,-280)
addPixel(300,-280)
addPixel(300,280)

addPixel(-300,280)  #TRIANGLE
addPixel(0,380)
addPixel(0,380)
addPixel(400,280)

addPixel(-230,-280)  #DOOR
addPixel(230,-280)
addPixel(-230,-280)
addPixel(-230,0)
addPixel(230,-280)
addPixel(230,0)
addPixel(230,0)
addPixel(-230,0)

addPixel(-230,220)  #left window
addPixel(-270,220)
addPixel(-230,250)
addPixel(-270,250)
addPixel(-230,220)
addPixel(-230,250)
addPixel(-270,220)
addPixel(-70,50)

addPixel(230,220)  #right window
addPixel(270,220)
addPixel(230,250)
addPixel(270,250)
addPixel(230,20)
addPixel(30,50)
addPixel(70,20)
addPixel(70,50)
gl.glEnd()

gl.glColor3f(.5,.5,.7)
gl.glBegin(gl.GL_POINTS)
addPixel(0,-40)
gl.glEnd()

img_buf = gl.glReadPixelsub(0, 0, WIDTH, HEIGHT, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
img = np.frombuffer(img_buf, np.uint8).reshape(HEIGHT, WIDTH, 3)[::-1]
show.image(img/255.0)

pixels_x_axis=[]
pixels_y_axis=[]
def drawLine(x0,y0,x1,y1):
  dx=x1-x0
  dy=y1-y0
  realZone=findRealZone(dx,dy)
  zone0_x0=convertToZone0_x(x0,y0,realZone)
  zone0_y0=convertToZone0_y(x0,y0,realZone)
  zone0_x1=convertToZone0_x(x1,y1,realZone)
  zone0_y1=convertToZone0_y(x1,y1,realZone)

  dx_prime= zone0_x1 - zone0_x0
  dy_prime=zone0_y1 - zone0_y0

  d=2*dy_prime-dx_prime
  east=2*dy_prime
  northEast=2*(dy_prime-dx_prime)
  x=zone0_x0
  y=zone0_y0
  while (x<=zone0_x1):
    n,p=zoneZeroToRealZone(x,y,realZone)
    pixels_x_axis.append(n)
    pixels_y_axis.append(p)
    if d>0:
      x+=1
      y+=1
      d=d+northEast
    else:
      x+=1
      d=d+east

def findRealZone(dx, dy):
    if abs(dx)>=abs(dy)and(dx>=0 and dy>=0):
        return 0

    elif abs(dy)>=abs(dx)and(dx>=0 and dy>=0):
        return 1

    elif abs(dy)>=abs(dx)and(dx<=0 and dy>=0):
        return 2

    elif abs(dx)>=abs(dy) and(dx<=0 and dy>=0):
        return 3
    elif abs(dx)>=abs(dy)and(dx<=0 and dy<=0):
        return 4
    elif abs(dy)>=abs(dx)and(dx<= 0 and dy<=0):
        return 5
    elif abs(dy)>=abs(dx) and (dx>=0 and dy<=0):
        return 6
    elif abs(dx)>= abs(dy) and (dx>=0 and dy<=0):
        return 7
def convertToZone0_x(x,y,realZone):
    if realZone==1:
      return y
    elif realZone==2:
      return y
    elif realZone==3:
      return -x
    elif realZone==4:
      return -x
    elif realZone==5:
      return -y
    elif realZone==6:
      return -y
    else:
      return x
def convertToZone0_y(x,y,realZone):
    if realZone==1:
      return x
    elif realZone==2:
      return -x
    elif realZone==4:
      return -y
    elif realZone==5:
      return -x
    elif realZone==6:
      return x
    elif realZone==7:
      return -y
    else: return y
    
    

def zoneZeroToRealZone(x,y,realZone):
    if realZone==0:
      return x,y
    if realZone==1:
      return y,x
    elif realZone==2:
      return -y,x
    elif realZone==3:
      return -x,y
    elif realZone==4:
      return -x,-y
    elif realZone==5:
      return -y,-x
    elif realZone==6:
      return y,-x
    elif realZone==7:
      return x,-y
    else: return x,y



string=str(input("enter your id:"))
h=10
k=100 
l=k+20


if int(string[len(string)-2])==4:
  drawLine(h,150,h,250)
  drawLine(h,150,k,150)
  drawLine(k,150,k,250)
  drawLine(k,150,k,75)

if int(string[len(string)-1])==6:
  drawLine(l,75,210,75)
  drawLine(l,150,210,150)
  drawLine(l,150,l,250)
  drawLine(l,150,l,75)
  drawLine(210,150,210,75)
  drawLine(l,250,210,250)




#for zone0
# drawLine(-200,-100,200,100)
#For Zone 1
# drawLine(-100,-200,100,200)
#for zone 2
# drawLine(100,-200,-100,200)
#for zone 4
#drawLine(200,100,-200,-100)
#for zone 5
# drawLine(100,200,-100,-200)
#for zone 6
# drawLine(100,-200,-100,200)
#for zone 7
# drawLine(200,-100,-200,100)






gl.glClear(gl.GL_COLOR_BUFFER_BIT)

gl.glColor3f(.5,.3,.7)
gl.glPointSize(5)

gl.glBegin(gl.GL_LINES)
gl.glVertex2f(0,-1)
gl.glVertex2f(0,1)
gl.glVertex2f(1,0)
gl.glVertex2f(-1,0)
gl.glEnd()

print(pixels_x_axis)
gl.glBegin(gl.GL_POINTS)
for i in range(len(pixels_x_axis)):
  addPixel(pixels_x_axis[i],pixels_y_axis[i])
gl.glEnd()

img_buf = gl.glReadPixelsub(0, 0, WIDTH, HEIGHT, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
img = np.frombuffer(img_buf, np.uint8).reshape(HEIGHT, WIDTH, 3)[::-1]
show.image(img/255.0)



def plotting_axis():
  gl.glClear(gl.GL_COLOR_BUFFER_BIT)

  gl.glColor3f(.5,.3,.7)
  gl.glPointSize(5)

  gl.glBegin(gl.GL_LINES)
  
  gl.glVertex2f(0,-1)
  gl.glVertex2f(0,1)
  gl.glVertex2f(1,0)
  gl.glVertex2f(-1,0)
  gl.glEnd()


def addPixel1(a,b):
  gl.glVertex2f(a/(WIDTH),b/(HEIGHT))

def midpointCircleAlgorithm(r,center_x,center_y):
    d=1-r
    x=0
    y=r
    while x<y:
        if d<0:
            d=d+2*x+3
            x=x+1
        else:
            d=d+(2*x)-(2*y)+5
            x=x+1
            y=y-1
        circleDrawingOfAllZones(x,y,center_x,center_y)


def circleDrawingOfAllZones(x,y,center_x,center_y):
    gl.glPointSize(1)
    gl.glBegin(gl.GL_POINTS)
    gl.glColor3f(.55,.13,.37)
    #pixels for all 8 zones
    addPixel1(y+center_x,-x+center_y)
    addPixel1(x+center_x,-y+center_y)
    addPixel1(-y+center_x,x+center_y)
    addPixel1(-x+center_x,-y+center_y)
    addPixel1(-y+center_x,-x+center_y)
    addPixel1(x+center_x,y+center_y)
    addPixel1(y+center_x,x+center_y)
    addPixel1(-x+center_x,y+center_y)
    gl.glEnd()
r=200
Xc=r+150
Yc=r+150
def start():
  midpointCircleAlgorithm(r,Xc,Yc)  #big circle
  midpointCircleAlgorithm(r/2,r+250,r+150)  #small circle
  midpointCircleAlgorithm(r/2,r+50,r+150)  #small circle
  midpointCircleAlgorithm(r/2,r+150,r+250)  #small circle
  midpointCircleAlgorithm(r/2,r+150,r+50)  #small circle



  import math
  midpointCircleAlgorithm(r/2,(Xc+(r/2)*(1/math.sqrt(2))),(Xc+(r/2)*(1/math.sqrt(2)))) 
  midpointCircleAlgorithm(r/2,(Xc-(r/2)*(1/math.sqrt(2))),(Xc+(r/2)*(1/math.sqrt(2)))) 
  midpointCircleAlgorithm(r/2,(Xc-(r/2)*(1/math.sqrt(2))),(Xc-(r/2)*(1/math.sqrt(2)))) 
  midpointCircleAlgorithm(r/2,(Xc+(r/2)*(1/math.sqrt(2))),(Xc-(r/2)*(1/math.sqrt(2)))) 

plotting_axis()
start()


img_buf = gl.glReadPixelsub(0, 0, WIDTH, HEIGHT, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
img = np.frombuffer(img_buf, np.uint8).reshape(HEIGHT, WIDTH, 3)[::-1]
show.image(img/255.0)

gl.glClear(gl.GL_COLOR_BUFFER_BIT)
gl.glPointSize(5)
gl.glBegin(gl.GL_LINES)
gl.glColor3f(.7,.2,.7)
gl.glVertex2f(0,-1)
gl.glVertex2f(0,1)
gl.glVertex2f(1,0)
gl.glVertex2f(-1,0)
gl.glEnd()

def addPixel(a,b):
  gl.glVertex2f(a/(WIDTH),b/(HEIGHT))




def convert_to_zone0(x,y,zone):
   if zone == '1':
       return (y, x)
   elif zone == '2':
       return (y, -x)
   elif zone == '3':
       return (-x, y)
   elif zone == '4':
       return (-x, -y)
   elif zone == '5':
       return (-y, -x)
   elif zone == '6':
       return (-y, x)
   elif zone == '7':
       return (x, -y)



def convert_to_original(x,y,zone):
   if zone == '1':
       return (y, x)
   elif zone == '2':
       return (-y, x)
   elif zone == '3':
       return (-x, y)
   elif zone == '4':
       return (-x, -y)
   elif zone == '5':
       return (-y, -x)
   elif zone == '6':
       return (y, -x)
   elif zone == '7':
       return (x, -y)



def mid_point_circle(radius):
   x =0
   y =radius
   d_init =1 - radius
   d = d_init
   pixel = []

   while x < y:
       pixel.append((x, y))

       if d >= 0:  #SE
           d += (2 * x) - (2 * y) + 5
           x += 1
           y -= 1

       else:       #E
           d += (2 * x) + 3
           x += 1

   return pixel


def draw_circle(x, y, radius):
   zone0 = []
   zone1 = mid_point_circle(radius)
   zone2 = []
   zone3 = []
   zone4 = []
   zone5 = []
   zone6 = []
   zone7 = []


   for (i, j) in zone1:
       zone0.append(convert_to_zone0(i, j, '1'))
   for (i, j) in zone0:
       zone2.append(convert_to_original(i, j, '2'))
       zone3.append(convert_to_original(i, j, '3'))
       zone4.append(convert_to_original(i, j, '4'))
       zone5.append(convert_to_original(i, j, '5'))
       zone6.append(convert_to_original(i, j, '6'))
       zone7.append(convert_to_original(i, j, '7'))


  
   gl.glPointSize(1)
   gl.glBegin(gl.GL_POINTS)
   gl.glColor3f(1.0, 0.75, 0.79)
   for (i, j) in zone0:
       addPixel(x+i, y+j)  #jekhane show korbe pixel
   for (i, j) in zone1:
       addPixel(x+i, y+j)
   for (i, j) in zone2:
       addPixel(x+i, y+j)
   for (i, j) in zone3:
       addPixel(x+i, y+j)
   for (i, j) in zone4:
       addPixel(x+i, y+j)
   for (i, j) in zone5:
       addPixel(x+i, y+j)
   for (i, j) in zone6:
       addPixel(x+i, y+j)
   for (i, j) in zone7:
       addPixel(x+i, y+j)


   gl.glEnd()





# bigger circle
draw_circle(250, 250, 200)




#circles with axis
draw_circle(350, 250, 100)
draw_circle(150, 250, 100)
draw_circle(250, 350, 100)
draw_circle(250, 150, 100)



#diagonal circles



#cos45= ? / radius
draw_circle((250 + (100 / 1.4142)), (250 + (100 / 1.4142)), 100)
draw_circle((250 - (100 / 1.4142)), (250 + (100 / 1.4142)), 100)
draw_circle((250 - (100 / 1.4142)), (250 - (100 / 1.4142)), 100)
draw_circle((250 + (100 / 1.4142)), (250 - (100 / 1.4142)), 100)



img_buf = gl.glReadPixelsub(0, 0, WIDTH, HEIGHT, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
img = np.frombuffer(img_buf, np.uint8).reshape(HEIGHT, WIDTH, 3)[::-1]
show.image(img/255.0)